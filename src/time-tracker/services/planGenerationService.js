import TimePlan from "../models/timePlan.js";
import Task from "../../models/Task.js";

/**
 * Generate plan instances from a task's time planning template
 * @param {Object} task - The task with timePlanning configuration
 * @param {Date} startDate - Start date for generation
 * @param {Date} endDate - End date for generation (optional, defaults to 14 days ahead)
 * @returns {Promise<Array>} Array of created/updated plan instances
 */
export async function generatePlanInstances(task, startDate, endDate = null) {
  const { timePlanning } = task;
  
  // Validate time planning is enabled and configured
  if (!timePlanning?.enabled || !timePlanning.defaultStartTime) {
    return [];
  }

  // If no endDate provided, generate 14 days ahead
  if (!endDate) {
    endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 14);
  }

  const instances = [];
  const currentDate = new Date(startDate);
  const end = new Date(endDate);

  // Parse default times
  const [startHours, startMins] = timePlanning.defaultStartTime.split(':').map(Number);
  let endHours, endMins;
  
  if (timePlanning.defaultEndTime) {
    [endHours, endMins] = timePlanning.defaultEndTime.split(':').map(Number);
  } else if (timePlanning.defaultDuration) {
    // Calculate end time from duration
    const totalMinutes = startHours * 60 + startMins + timePlanning.defaultDuration;
    endHours = Math.floor(totalMinutes / 60) % 24;
    endMins = totalMinutes % 60;
  } else {
    // Default to 1 hour if neither endTime nor duration provided
    const totalMinutes = startHours * 60 + startMins + 60;
    endHours = Math.floor(totalMinutes / 60) % 24;
    endMins = totalMinutes % 60;
  }

  while (currentDate <= end) {
    // Check recurrence pattern
    const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 6 = Saturday
    const shouldCreate = 
      timePlanning.recurrence.type === "daily" ||
      (timePlanning.recurrence.type === "weekdays" && dayOfWeek >= 1 && dayOfWeek <= 5);

    if (shouldCreate) {
      // Normalize date to start of day for instanceDate
      const instanceDate = new Date(currentDate);
      instanceDate.setHours(0, 0, 0, 0);

      // Check if instance already exists (user may have overridden)
      // Also check by startTime range for backward compatibility
      const dayStart = new Date(instanceDate);
      const dayEnd = new Date(instanceDate);
      dayEnd.setHours(23, 59, 59, 999);
      
      const existing = await TimePlan.findOne({
        userId: task.userId,
        taskId: task._id,
        $or: [
          { instanceDate: instanceDate },
          { startTime: { $gte: dayStart, $lte: dayEnd } } // Fallback for old plans
        ]
      });

      // Only create/update if it doesn't exist or is auto-generated (not overridden)
      if (!existing || (existing.isAutoGenerated && !existing.isOverridden)) {
        // Create plan start/end times for this specific date
        const planStart = new Date(instanceDate);
        planStart.setHours(startHours, startMins, 0, 0);
        
        const planEnd = new Date(instanceDate);
        planEnd.setHours(endHours, endMins, 0, 0);

        // If end time is before start time, it means it wraps to next day
        if (planEnd < planStart) {
          planEnd.setDate(planEnd.getDate() + 1);
        }

        const instance = await TimePlan.findOneAndUpdate(
          {
            userId: task.userId,
            taskId: task._id,
            instanceDate: instanceDate
          },
          {
            userId: task.userId,
            taskId: task._id,
            taskTitle: task.title,
            groupTag: task.groupTag || "@personal",
            categoryId: timePlanning.categoryId || "work",
            startTime: planStart,
            endTime: planEnd,
            instanceDate: instanceDate,
            isAutoGenerated: true,
            isOverridden: false,
            templateStartTime: timePlanning.defaultStartTime,
            templateEndTime: timePlanning.defaultEndTime || null,
            status: "scheduled"
          },
          { upsert: true, new: true }
        );
        
        instances.push(instance);
      }
    }

    // Move to next day
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Update task metadata
  if (instances.length > 0) {
    await Task.findByIdAndUpdate(task._id, {
      'timePlanning.lastPlanGenerated': new Date(),
      'timePlanning.planInstanceCount': instances.length
    });
  }

  return instances;
}

/**
 * Cancel future auto-generated plans for a task
 * @param {String} userId - User ID
 * @param {String} taskId - Task ID
 * @returns {Promise<Number>} Number of plans canceled
 */
export async function cancelFuturePlans(userId, taskId) {
  const result = await TimePlan.updateMany(
    {
      userId: userId,
      taskId: taskId,
      instanceDate: { $gte: new Date() },
      isAutoGenerated: true,
      status: "scheduled"
    },
    {
      status: "canceled"
    }
  );

  return result.modifiedCount;
}

/**
 * Generate plans for a task that just moved to in-progress
 * @param {Object} task - The task that moved to in-progress
 * @returns {Promise<Array>} Array of created plan instances
 */
export async function generatePlansForInProgressTask(task) {
  if (!task.timePlanning?.enabled || !task.timePlanning.autoPlanOnStart) {
    return [];
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Update recurrence activation date
  await Task.findByIdAndUpdate(task._id, {
    'timePlanning.recurrence.activatedAt': new Date()
  });

  return await generatePlanInstances(task, today);
}

